#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "../RayTracing/host_device.glsl"
#include "../RayTracing/raycommon.glsl"
#include "../Utility/random.glsl"

layout(local_size_x = 16, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;
layout(binding = 2, set = 0, scalar) buffer Vertices {
  vec3 vertices[];
};
layout(binding = 3, set = 0, scalar) buffer Indices { uint16_t indices[]; };

layout(binding = 0, set = 1) uniform _GlobalUniforms { GlobalUniforms uni; };

#include "../RayTracing/RayQuery/include/rayquery_utils.glsl"

void main()
{  
    const uvec2 resolution = uvec2(800, 600);
    const uvec2 pixel = gl_GlobalInvocationID.xy;
    if(gl_GlobalInvocationID.x >= resolution.x || gl_GlobalInvocationID.y >= resolution.y) return;
    // State of the random number generator.
    uint rngState = resolution.x * pixel.y + pixel.x;  // Initial seed

    vec4 origin    = uni.viewInverse * vec4(0, 0, 0, 1);

    // The sum of the colors of all of the samples.
    vec3 summedPixelColor = vec3(0.0);
    // Limit the kernel to trace at most 64 samples.
    const int NUM_SAMPLES = 32;
    for(int sampleIdx = 0; sampleIdx < NUM_SAMPLES; sampleIdx++) {
        const vec2 pixelCenter = vec2(pixel.xy) + vec2(stepAndOutputRNGFloat(rngState), stepAndOutputRNGFloat(rngState));
        const vec2 inUV = pixelCenter/vec2(resolution.xy);
        vec2 d = inUV * 2.0 - 1.0;
        vec4 target    = uni.projInverse * vec4(d.x, d.y, 1, 1);
        vec4 direction = uni.viewInverse * vec4(normalize(target.xyz), 0);
        vec3 rayDirection = direction.xyz;
        rayDirection      = normalize(rayDirection);
        vec3 rayOrigin = origin.xyz;

        vec3 accumulatedRayColor = vec3(1.0);  // The amount of light that made it to the end of the current ray.
        vec3 pixelColor          = vec3(0.0);

        // Limit the kernel to trace at most 32 segments.
        for(int tracedSegments = 0; tracedSegments < 32; tracedSegments++) {
            // Trace the ray and see if and where it intersects the scene!
            // First, initialize a ray query object:
            rayQueryEXT rayQuery;
            rayQueryInitializeEXT(rayQuery,              // Ray query
                                topLevelAS,                  // Top-level acceleration structure
                                gl_RayFlagsOpaqueEXT,  // Ray flags, here saying "treat all geometry as opaque"
                                0xFF,                  // 8-bit instance mask, here saying "trace against all instances"
                                rayOrigin,             // Ray origin
                                0.0,                   // Minimum t-value
                                rayDirection,          // Ray direction
                                10000.0);              // Maximum t-value
            // Start traversal, and loop over all ray-scene intersections. When this finishes,
            // rayQuery stores a "committed" intersection, the closest intersection (if any).
            while(rayQueryProceedEXT(rayQuery)) {}
            // Get the type of committed (true) intersection - nothing, a triangle, or
            // a generated object
            if(rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT) {
                // Ray hit a triangle
                HitInfo hitInfo = getObjectHitInfo(rayQuery);
                // Apply color absorption
                accumulatedRayColor *= hitInfo.color;
                // Start a new ray at the hit position:
                rayOrigin = hitInfo.worldPosition;
                // Flip the normal so it points against the ray direction:
                hitInfo.worldNormal = faceforward(hitInfo.worldNormal, rayDirection, hitInfo.worldNormal);
                // Reflect the direction of the ray using the triangle normal:
                // rayDirection = reflect(rayDirection, hitInfo.worldNormal);
                rayDirection = hitInfo.worldNormal + randomPointInSphere(rngState);
                // Start a new ray at the hit position, but offset it slightly along
                // the normal:
                rayOrigin = hitInfo.worldPosition + 0.0001 * hitInfo.worldNormal;

            }
            else {
                // Ray hit the sky
                pixelColor = accumulatedRayColor * skyColor(rayDirection);
                break;
            }
        }
        summedPixelColor += pixelColor;
    }

    imageStore(image, ivec2(pixel), vec4(summedPixelColor/float(NUM_SAMPLES), 1.0));
}
