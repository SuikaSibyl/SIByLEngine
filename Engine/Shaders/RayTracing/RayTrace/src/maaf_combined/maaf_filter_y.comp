#version 460
#extension GL_EXT_scalar_block_layout : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "maaf_common.h"

layout(binding = 0, set = 0, scalar) readonly buffer defocusSlopeBuffer     { vec2 defocus_slope[]; };
layout(binding = 1, set = 0, scalar) readonly buffer directSlopeBuffer      { vec2 direct_slope[]; };
layout(binding = 2, set = 0, scalar) readonly buffer indirectSlopeBuffer    { vec2 indirect_slope[]; };
layout(binding = 3, set = 0, scalar) readonly buffer worldPositionBuffer    { vec4 world_position[]; };
layout(binding = 4, set = 0, scalar) readonly buffer worldNormalBuffer      { vec3 world_normal[]; };
layout(binding = 5, set = 0, scalar) readonly buffer useFilterBuffer        { uint use_filter[]; };
layout(binding = 6, set = 0, scalar) readonly buffer MAAFParametersBuffer               { MAAFParametersGroup params[]; };
layout(binding = 7, set = 0, scalar) writeonly buffer MAAFIntermediateDirectBuffer       { IntermediateStruct directIntermediate[]; };
layout(binding = 8, set = 0, scalar) writeonly buffer MAAFIntermediateIndirectBuffer     { IntermediateStruct indirectIntermediate[]; };
layout(binding = 9, set = 0, rgba32f) uniform image2D storageImage;

layout(binding = 10, set = 0, scalar) writeonly buffer defocusSlopeTmpBuffer     { vec2 defocus_slope_tmp[]; };
layout(binding = 11, set = 0, scalar) writeonly buffer directSlopeTmpBuffer      { vec2 direct_slope_tmp[]; };
layout(binding = 12, set = 0, scalar) writeonly buffer indirectSlopeTmpBuffer    { vec2 indirect_slope_tmp[]; };
layout(binding = 13, set = 0, scalar) writeonly buffer worldPositionTmpBuffer    { vec4 world_position_tmp[]; };
layout(binding = 14, set = 0, scalar) writeonly buffer worldNormalTmpBuffer      { vec3 world_normal_tmp[]; };
layout(binding = 15, set = 0, scalar) writeonly buffer useFilterTmpBuffer        { uint use_filter_tmp[]; };
layout(binding = 16, set = 0, scalar) readonly buffer MAAFIntermediateDirectTmpBuffer      { IntermediateStruct directIntermediateTmp[]; };
layout(binding = 17, set = 0, scalar) readonly buffer MAAFIntermediateIndirectTmpBuffer    { IntermediateStruct indirectIntermediateTmp[]; };

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

void main()
{
    // Get current pixel position and global index.
    const uvec2 pixel = gl_GlobalInvocationID.xy;
    // If the pixel is outside of the image, don't do anything:
    if((pixel.x >= resolution.x) || (pixel.y >= resolution.y))
        return;
    // else compute the gid
    const uint gid = pixel.x + pixel.y * resolution.x;

    // return if do not use filter
    uint center_use_filter = use_filter[gid];
    if(center_use_filter==0) return;

    // TODO:: Further restrict the filter size by sigmaxp
    const MAAFParametersGroup group = params[gid];
    const vec4  center_world_pos = world_position[gid];
    const vec3  center_world_norm = world_normal[gid];
    IntermediateStruct directInterm;
    IntermediateStruct indircInterm;

    clearIntermediateStruct(directInterm);
    clearIntermediateStruct(indircInterm);

    for (int i=int(pixel.y)-filter_radius; i<=int(pixel.y)+filter_radius; i++) {
        if (i < 0 || i >= resolution.y) continue;
        uint neighbor_gid = pixel.x + i*resolution.x;
        if(use_filter[neighbor_gid] == 0) continue;
        // neighbor information fetching
        const vec4 neighbor_world_pos = world_position[neighbor_gid];
        const vec3 neighbor_world_norm = world_normal[neighbor_gid];
        if(abs(dot(center_world_norm, neighbor_world_norm)) < cos_angle_threshold) continue;
        const vec3 diff = center_world_pos.xyz - neighbor_world_pos.xyz;
        const float euclidean_distancesq = dot(diff, diff);
        const float normcomp = dot(diff, light_normal);
        const float distancesq = euclidean_distancesq - normcomp*normcomp;
        // TODO:: Check whether use the condition (if has defocus blur)
        // if (distancesq >= dist_threshold) continue;

        IntermediateStruct neighbor_directInterm = directIntermediateTmp[neighbor_gid];
        IntermediateStruct neighbor_indirectInterm = indirectIntermediateTmp[neighbor_gid];
        // TODO:: Check whether each box is valid
        // TODO:: Use per box scaling
        float triweight[5];
        float weight[5];

        const float dist = sqrt(distancesq);
        const float pix_dist = float(i-int(pixel.y));
        const float pix_dist_sq = pix_dist*pix_dist;
        float scaling_1 = group.directParams.scaling[0];
        float scaling_2 = group.directParams.scaling[1];

        float weight_1 = unnormalized_gaussian_sq(pix_dist_sq, group.directParams.sigmaxp[1]) * scaling_1;
        float weight_2 = unnormalized_gaussian_sq(pix_dist_sq, group.directParams.sigmaxp[2]) * scaling_2;
        // TODO :: pix_dist*2*k_pi?
        triweight[0] = unnormalized_gaussian_sq(pix_dist_sq, group.directParams.sigmaxp[0]);
        triweight[1] = weight_1 * cos(group.directParams.cxp[1] * pix_dist * 2*k_pi);
        triweight[2] = weight_2 * cos(group.directParams.cxp[2] * pix_dist * 2*k_pi);
        triweight[3] = weight_1 * sin(group.directParams.cxp[1] * pix_dist * 2*k_pi);
        triweight[4] = weight_2 * sin(group.directParams.cxp[2] * pix_dist * 2*k_pi);
        weight[0] = triweight[0];
        weight[1] = weight_1;
        weight[2] = weight_2;
        weight[3] = weight_1;
        weight[4] = weight_2;

        for(int i=0; i<5; ++i)
            for(int j=0; j<5; ++j)
                directInterm.data[i*5+j] += neighbor_directInterm.data[i*5+j] * vec4(vec3(triweight[j]), weight[j]);

        scaling_1 = group.indirectParams.scaling[0];
        scaling_2 = group.indirectParams.scaling[1];
        weight_1 = unnormalized_gaussian_sq(pix_dist_sq, group.indirectParams.sigmaxp[1]) * scaling_1;
        weight_2 = unnormalized_gaussian_sq(pix_dist_sq, group.indirectParams.sigmaxp[2]) * scaling_2;
        triweight[0] = unnormalized_gaussian_sq(pix_dist_sq, group.indirectParams.sigmaxp[0]);
        triweight[1] = weight_1 * cos(group.indirectParams.cxp[1] * pix_dist * 2*k_pi);
        triweight[2] = weight_2 * cos(group.indirectParams.cxp[2] * pix_dist * 2*k_pi);
        triweight[3] = weight_1 * sin(group.indirectParams.cxp[1] * pix_dist * 2*k_pi);
        triweight[4] = weight_2 * sin(group.indirectParams.cxp[2] * pix_dist * 2*k_pi);
        weight[0] = triweight[0];
        weight[1] = weight_1;
        weight[2] = weight_2;
        weight[3] = weight_1;
        weight[4] = weight_2;

        for(int i=0; i<5; ++i)
            for(int j=0; j<5; ++j)
                indircInterm.data[i*5+j] += neighbor_indirectInterm.data[i*5+j] * vec4(vec3(triweight[j]), weight[j]);
    }

    directIntermediate[gid]   = directInterm;
    indirectIntermediate[gid] = indircInterm;
    return;
}