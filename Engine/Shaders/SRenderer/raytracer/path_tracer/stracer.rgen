#version 460
#extension GL_GOOGLE_include_directive : enable

struct PushConstants { uint sample_batch; };
layout(push_constant) uniform PushConsts { PushConstants pushConstants; };

#include "../../include/common_trace.h"

layout(location = 0) rayPayloadEXT vec3 hitValue;

const ivec2 resolution = ivec2(800,600);

void main() {
    // The resolution of the image, which is the same as the launch size:
    const ivec2 pixel = ivec2(gl_LaunchIDEXT.xy);
    // If the pixel is outside of the image, don't do anything:
    if((pixel.x >= resolution.x) || (pixel.y >= resolution.y)) {
        return;
    }
    
    // As we only use 1spp, no random offset.
    const vec2 pixelCenter  = vec2(pixel.xy) + vec2(0.5);
    const vec2 inUV         = pixelCenter/vec2(resolution.xy);
    const vec2 d            = inUV * 2.0 - 1.0;

    const float focus_dist = 0.0f;
    const float length_radius = 0.;
    const vec3 targetOnFocusPlane = (globalUniform.projInverse * vec4(d.x, d.y, 1, 1)).xyz;
    const vec2 diskSample = vec2(0);
    // const vec2 diskSample = uniformSampleDisk(vec2(stepAndOutputRNGFloat(pld.rngState), stepAndOutputRNGFloat(pld.rngState)));
    const vec3 sampleOnApeture = vec3(length_radius * diskSample, 0);
    const vec4 origin       = globalUniform.viewInverse * vec4(vec3(0), 1);
    const vec4 direction    = globalUniform.viewInverse * vec4(normalize(targetOnFocusPlane - sampleOnApeture), 0);
 
    vec3 rayDirection = normalize(direction.xyz);
    vec3 rayOrigin    = origin.xyz;

    traceRayEXT(tlas,                  // Top-level acceleration structure
                gl_RayFlagsOpaqueEXT,  // Ray flags, here saying "treat all geometry as opaque"
                0xFF,                  // 8-bit instance mask, here saying "trace against all instances"
                0,                     // SBT record offset
                0,                     // SBT record stride for offset
                0,                     // Miss index
                rayOrigin,             // Ray origin
                0.0,                   // Minimum t-value
                rayDirection,          // Ray direction
                10000.0,               // Maximum t-value
                0);                    // Location of payload

    // if(pushConstants.sample_batch != 0) {
    //     vec3 color = imageLoad(storageImage, ivec2(pixel)).rgb;
    //     pixelColor = (pushConstants.sample_batch * color + pixelColor) / (pushConstants.sample_batch + 1);
    // }
    imageStore(storageImage, pixel, vec4(hitValue, 1.0));
}