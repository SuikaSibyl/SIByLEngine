export module Tracer.Interactable:Interaction.SurfaceInteraction;
import :Interaction;
import :Material;
import Core.Memory;
import Math.Vector;
import Math.Geometry;
import Math.Transform;
import Tracer.Shape;
import Tracer.Ray;
import Tracer.Spectrum;

namespace SIByL::Tracer
{
	export struct Primitive;
	export struct BSDF;
	export struct BSSRDF;
	/**
	* Represent local information at a point on a 2D surface.
	* Supply enough information about the surface point.
	*/
	export struct SurfaceInteraction :public Interaction
	{
		SurfaceInteraction();
		SurfaceInteraction(Math::point3 const& p, Math::point3 const& pError,
			Math::point2 const& uv, Math::vec3 const& wo,
			Math::vec3 const& dpdu, Math::vec3 const& dpdv,
			Math::normal3 const& dndu, Math::vec3 const& dndv,
			float time, Shape const* shape);

		/**
		* Set shading geometry, a second instance of geometry information,
		* generated by bump mapping or interpolated per-vertex normals with triangles.
		* @see SurfaceInteraction::shading
		*/
		auto setShadingGeometry(Math::vec3 const& dpdus, Math::vec3 const& dpdvs,
			Math::normal3 const& dndus, Math::normal3 const& dndvs, bool orientationIsAuthoritative) noexcept -> void;

		auto computeScatteringFunctions(RayDifferential const& ray, Core::MemoryArena& arena, bool allowMultipleLobes = false, TransportMode mode = TransportMode::Radiance) noexcept -> void;

		auto computeDifferentials(RayDifferential const& ray) const noexcept -> void;

		auto Le(Math::vec3 const& w) const noexcept -> Spectrum;

		/** parameterizeation of the surface */
		Math::point2 uv;
		/** the parametric partial derivatives of the point ∂p/∂u and ∂p/∂v */
		Math::vec3 dpdu, dpdv;
		/** the differential change in surface normal as we move u and v along the surface */
		Math::normal3 dndu, dndv;

		/** the Shape that the point lies on */
		Shape const* shape = nullptr;
		/** the Primitive that the ray hits */
		Primitive const* primitive = nullptr;

		mutable Math::vec3 dpdx, dpdy;
		mutable float dudx = 0, dvdx = 0, dudy = 0, dvdy = 0;

		BSDF* bsdf = nullptr;
		BSSRDF* bssrdf = nullptr;

		/**
		* The shading geometry, a second instance of geometry information.
		* Which can be generated by bump mapping or interpolated per-vertex normals with triangles.
		*/
		struct {
			Math::normal3 n;
			Math::vec3 dpdu, dpdv;
			Math::normal3 dndu, dndv;
		} shading;
	};
}

namespace SIByL::Math
{
	export inline auto operator*(Transform const& t, Tracer::SurfaceInteraction const& si)->Tracer::SurfaceInteraction;
	export inline auto operator*(AnimatedTransform const& t, Tracer::SurfaceInteraction const& si)->Tracer::SurfaceInteraction;
}
